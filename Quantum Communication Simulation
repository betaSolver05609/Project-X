# First install required packages with visualization extras
!pip install -q "qiskit[visualization]" qiskit-aer matplotlib numpy

# Add magic command for displaying plots in Colab
%matplotlib inline

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator
import numpy as np
import matplotlib.pyplot as plt

# Parameters
n = 3  # input size
i = [1, 0, 1]  # classical input
trials = 100  # number of trials per attack type
shots = 100   # shots per simulation

# Define attack types
attack_types = {
    'Honest': None,
    'Bit Flip (X)': lambda qc: qc.x(0),
    'Phase Flip (Z)': lambda qc: qc.z(0),
    'Entanglement (CX)': lambda qc: qc.cx(0, 1),
    'Hadamard': lambda qc: qc.h(0),
    'Random Gate': lambda qc: [qc.x(0), qc.z(1), qc.h(2)][np.random.randint(3)]
}

# Store results
results = {attack: [] for attack in attack_types}

print("Running simulations...")
for attack_name, attack_func in attack_types.items():
    print(f"Testing attack: {attack_name}")
    
    for trial in range(trials):
        # Generate new random basis for each trial
        r = np.random.randint(2, size=n)
        
        # Create circuit
        qc = QuantumCircuit(n, n)
        
        # Step 1: Client Encoding
        for idx, bit in enumerate(i):
            if bit == 1:
                qc.x(idx)
        for idx, rand in enumerate(r):
            if rand == 1:
                qc.h(idx)
                
        qc.barrier()
        
        # Step 2: Apply attack if defined
        if attack_func:
            attack_func(qc)
            
        qc.barrier()
        
        # Step 3: Client Decoding
        for idx, rand in enumerate(r):
            if rand == 1:
                qc.h(idx)
        qc.measure(range(n), range(n))
        
        # Run simulation
        simulator = AerSimulator()
        job = simulator.run(qc, shots=shots)
        result = job.result()
        counts = result.get_counts()
        
        # Convert to big-endian order
        counts_big_endian = {k[::-1]: v for k, v in counts.items()}
        
        # Calculate success rate
        expected_output = ''.join(str(bit) for bit in i)
        success_count = counts_big_endian.get(expected_output, 0)
        success_rate = success_count / shots
        results[attack_name].append(success_rate)

# Calculate average success rates
avg_success = {attack: np.mean(rates) * 100 for attack, rates in results.items()}
std_dev = {attack: np.std(rates) * 100 for attack, rates in results.items()}

# Create plot
plt.figure(figsize=(12, 6))

# Get attack names and values in consistent order
attacks = list(attack_types.keys())
values = [avg_success[attack] for attack in attacks]
errors = [std_dev[attack] for attack in attacks]

# Create bar plot with error bars
bars = plt.bar(attacks, values, yerr=errors, capsize=10, 
               color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'])

# Add values on top of bars
for bar, val in zip(bars, values):
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 2, 
             f'{val:.1f}%', ha='center', va='bottom', fontsize=10)

# Format plot
plt.axhline(y=100, color='gray', linestyle='--', alpha=0.7)
plt.title('Acceptance Rate vs Attack Type', fontsize=16)
plt.ylabel('Success Rate (%)', fontsize=14)
plt.xlabel('Attack Type', fontsize=14)
plt.ylim(0, 120)
plt.grid(axis='y', alpha=0.3)
plt.xticks(fontsize=12)

# Add explanation
plt.figtext(0.5, -0.1, 
            "Note: Honest server has no attack. Security comes from random basis choices - "
            "attacks have 50% chance per qubit of being incompatible with measurement basis.",
            wrap=True, horizontalalignment='center', fontsize=12)

plt.tight_layout()
plt.show()
